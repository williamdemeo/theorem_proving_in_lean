
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ascii" />
    <title>3. Propositions and Proofs &#8212; Theorem Proving in Lean 3.4.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.4.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="4. Quantifiers and Equality" href="quantifiers_and_equality.html" />
    <link rel="prev" title="2. Dependent Type Theory" href="dependent_type_theory.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="propositions-and-proofs">
<span id="id1"></span><h1>3. Propositions and Proofs<a class="headerlink" href="#propositions-and-proofs" title="Permalink to this headline">&#182;</a></h1>
<p>By now, you have seen some ways of defining objects and functions in Lean. In this chapter, we will begin to explain how to write mathematical assertions and proofs in the language of dependent type theory as well.</p>
<div class="section" id="propositions-as-types">
<h2>3.1. Propositions as Types<a class="headerlink" href="#propositions-as-types" title="Permalink to this headline">&#182;</a></h2>
<p>One strategy for proving assertions about objects defined in the language of dependent type theory is to layer an assertion language and a proof language on top of the definition language. But there is no reason to multiply languages in this way: dependent type theory is flexible and expressive, and there is no reason we cannot represent assertions and proofs in the same general framework.</p>
<p>For example, we could introduce a new type, <code class="docutils literal"><span class="pre">Prop</span></code>, to represent propositions, and introduce constructors to build new propositions from others.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=namespace%20hidden%0A%0A--%20BEGIN%0Aconstant%20and%20:%20Prop%20%E2%86%92%20Prop%20%E2%86%92%20Prop%0Aconstant%20or%20:%20Prop%20%E2%86%92%20Prop%20%E2%86%92%20Prop%0Aconstant%20not%20:%20Prop%20%E2%86%92%20Prop%0Aconstant%20implies%20:%20Prop%20%E2%86%92%20Prop%20%E2%86%92%20Prop%0A%0Avariables%20p%20q%20r%20:%20Prop%0A#check%20and%20p%20q%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20Prop%0A#check%20or%20(and%20p%20q)%20r%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20Prop%0A#check%20implies%20(and%20p%20q)%20(and%20q%20p)%20%20--%20Prop%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">constant</span> <span class="n">and</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span>
<span class="kd">constant</span> <span class="n">or</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span>
<span class="kd">constant</span> <span class="n">not</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span>
<span class="kd">constant</span> <span class="n">implies</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span>

<span class="kd">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="k">#check</span> <span class="n">and</span> <span class="n">p</span> <span class="n">q</span>                      <span class="c1">-- Prop</span>
<span class="k">#check</span> <span class="n">or</span> <span class="o">(</span><span class="n">and</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="n">r</span>               <span class="c1">-- Prop</span>
<span class="k">#check</span> <span class="n">implies</span> <span class="o">(</span><span class="n">and</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">and</span> <span class="n">q</span> <span class="n">p</span><span class="o">)</span>  <span class="c1">-- Prop</span>
</pre></div>
</div>
</div><p>We could then introduce, for each element <code class="docutils literal"><span class="pre">p</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, another type <code class="docutils literal"><span class="pre">Proof</span> <span class="pre">p</span></code>, for the type of proofs of <code class="docutils literal"><span class="pre">p</span></code>. An &#8220;axiom&#8221; would be a constant of such a type.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=namespace%20hidden%0A%0Aconstant%20and%20:%20Prop%20%E2%86%92%20Prop%20%E2%86%92%20Prop%0Aconstant%20or%20:%20Prop%20%E2%86%92%20Prop%20%E2%86%92%20Prop%0Aconstant%20not%20:%20Prop%20%E2%86%92%20Prop%0Aconstant%20implies%20:%20Prop%20%E2%86%92%20Prop%20%E2%86%92%20Prop%0A%0A--%20BEGIN%0Aconstant%20Proof%20:%20Prop%20%E2%86%92%20Type%0A%0Aconstant%20and_comm%20:%20%CE%A0%20p%20q%20:%20Prop,%0A%20%20Proof%20(implies%20(and%20p%20q)%20(and%20q%20p))%0A%0Avariables%20p%20q%20:%20Prop%0A#check%20and_comm%20p%20q%20%20%20%20%20%20--%20Proof%20(implies%20(and%20p%20q)%20(and%20q%20p))%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">constant</span> <span class="n">Proof</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="bp">&#8594;</span> <span class="kt">Type</span>

<span class="kd">constant</span> <span class="n">and_comm</span> <span class="o">:</span> <span class="bp">&#928;</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
  <span class="n">Proof</span> <span class="o">(</span><span class="n">implies</span> <span class="o">(</span><span class="n">and</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">and</span> <span class="n">q</span> <span class="n">p</span><span class="o">))</span>

<span class="kd">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="k">#check</span> <span class="n">and_comm</span> <span class="n">p</span> <span class="n">q</span>      <span class="c1">-- Proof (implies (and p q) (and q p))</span>
</pre></div>
</div>
</div><p>In addition to axioms, however, we would also need rules to build new proofs from old ones. For example, in many proof systems for propositional logic, we have the rule of modus ponens:</p>
<blockquote>
<div>From a proof of <code class="docutils literal"><span class="pre">implies</span> <span class="pre">p</span> <span class="pre">q</span></code> and a proof of <code class="docutils literal"><span class="pre">p</span></code>, we obtain a proof of <code class="docutils literal"><span class="pre">q</span></code>.</div></blockquote>
<p>We could represent this as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=namespace%20hidden%0A%0Aconstant%20implies%20:%20Prop%20%E2%86%92%20Prop%20%E2%86%92%20Prop%0Aconstant%20Proof%20:%20Prop%20%E2%86%92%20Type%0A%0A--%20BEGIN%0Aconstant%20modus_ponens%20:%0A%20%20%CE%A0%20p%20q%20:%20Prop,%20Proof%20(implies%20p%20q)%20%E2%86%92%20%20Proof%20p%20%E2%86%92%20Proof%20q%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">constant</span> <span class="n">modus_ponens</span> <span class="o">:</span>
  <span class="bp">&#928;</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="n">Proof</span> <span class="o">(</span><span class="n">implies</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span>  <span class="n">Proof</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">Proof</span> <span class="n">q</span>
</pre></div>
</div>
</div><p>Systems of natural deduction for propositional logic also typically rely on the following rule:</p>
<blockquote>
<div>Suppose that, assuming <code class="docutils literal"><span class="pre">p</span></code> as a hypothesis, we have a proof of <code class="docutils literal"><span class="pre">q</span></code>. Then we can &#8220;cancel&#8221; the hypothesis and obtain a proof of <code class="docutils literal"><span class="pre">implies</span> <span class="pre">p</span> <span class="pre">q</span></code>.</div></blockquote>
<p>We could render this as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=namespace%20hidden%0A%0Aconstant%20implies%20:%20Prop%20%E2%86%92%20Prop%20%E2%86%92%20Prop%0Aconstant%20Proof%20:%20Prop%20%E2%86%92%20Type%0A%0A--%20BEGIN%0Aconstant%20implies_intro%20:%0A%20%20%CE%A0%20p%20q%20:%20Prop,%20(Proof%20p%20%E2%86%92%20Proof%20q)%20%E2%86%92%20Proof%20(implies%20p%20q).%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">constant</span> <span class="n">implies_intro</span> <span class="o">:</span>
  <span class="bp">&#928;</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="o">(</span><span class="n">Proof</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">Proof</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">Proof</span> <span class="o">(</span><span class="n">implies</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span>
</pre></div>
</div>
</div><p>This approach would provide us with a reasonable way of building assertions and proofs. Determining that an expression <code class="docutils literal"><span class="pre">t</span></code> is a correct proof of assertion <code class="docutils literal"><span class="pre">p</span></code> would then simply be a matter of checking that <code class="docutils literal"><span class="pre">t</span></code> has type <code class="docutils literal"><span class="pre">Proof</span> <span class="pre">p</span></code>.</p>
<p>Some simplifications are possible, however. To start with, we can avoid writing the term <code class="docutils literal"><span class="pre">Proof</span></code> repeatedly by conflating <code class="docutils literal"><span class="pre">Proof</span> <span class="pre">p</span></code> with <code class="docutils literal"><span class="pre">p</span></code> itself. In other words, whenever we have <code class="docutils literal"><span class="pre">p</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, we can interpret <code class="docutils literal"><span class="pre">p</span></code> as a type, namely, the type of its proofs. We can then read <code class="docutils literal"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">p</span></code> as the assertion that <code class="docutils literal"><span class="pre">t</span></code> is a proof of <code class="docutils literal"><span class="pre">p</span></code>.</p>
<p>Moreover, once we make this identification, the rules for implication show that we can pass back and forth between <code class="docutils literal"><span class="pre">implies</span> <span class="pre">p</span> <span class="pre">q</span></code> and <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code>. In other words, implication between propositions <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code> corresponds to having a function that takes any element of <code class="docutils literal"><span class="pre">p</span></code> to an element of <code class="docutils literal"><span class="pre">q</span></code>. As a result, the introduction of the connective <code class="docutils literal"><span class="pre">implies</span></code> is entirely redundant: we can use the usual function space constructor <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code> from dependent type theory as our notion of implication.</p>
<p>This is the approach followed in the Calculus of Constructions, and hence in Lean as well. The fact that the rules for implication in a proof system for natural deduction correspond exactly to the rules governing abstraction and application for functions is an instance of the <em>Curry-Howard isomorphism</em>, sometimes known as the <em>propositions-as-types</em> paradigm. In fact, the type <code class="docutils literal"><span class="pre">Prop</span></code> is syntactic sugar for <code class="docutils literal"><span class="pre">Sort</span> <span class="pre">0</span></code>, the very bottom of the type hierarchy described in the last chapter. Moreover, <code class="docutils literal"><span class="pre">Type</span> <span class="pre">u</span></code> is also just syntactic sugar for <code class="docutils literal"><span class="pre">Sort</span> <span class="pre">(u+1)</span></code>. <code class="docutils literal"><span class="pre">Prop</span></code> has some special features, but like the other type universes, it is closed under the arrow constructor: if we have <code class="docutils literal"><span class="pre">p</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, then <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Prop</span></code>.</p>
<p>There are at least two ways of thinking about propositions as types. To some who take a constructive view of logic and mathematics, this is a faithful rendering of what it means to be a proposition: a proposition <code class="docutils literal"><span class="pre">p</span></code> represents a sort of data type, namely, a specification of the type of data that constitutes a proof. A proof of <code class="docutils literal"><span class="pre">p</span></code> is then simply an object <code class="docutils literal"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">p</span></code> of the right type.</p>
<p>Those not inclined to this ideology can view it, rather, as a simple coding trick. To each proposition <code class="docutils literal"><span class="pre">p</span></code> we associate a type, which is empty if <code class="docutils literal"><span class="pre">p</span></code> is false and has a single element, say <code class="docutils literal"><span class="pre">*</span></code>, if <code class="docutils literal"><span class="pre">p</span></code> is true. In the latter case, let us say that (the type associated with) <code class="docutils literal"><span class="pre">p</span></code> is <em>inhabited</em>. It just so happens that the rules for function application and abstraction can conveniently help us keep track of which elements of <em>Prop</em> are inhabited. So constructing an element <code class="docutils literal"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">p</span></code> tells us that <code class="docutils literal"><span class="pre">p</span></code> is indeed true. You can think of the inhabitant of <code class="docutils literal"><span class="pre">p</span></code> as being the &#8220;fact that <code class="docutils literal"><span class="pre">p</span></code> is true.&#8221; A proof of <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code> uses &#8220;the fact that <code class="docutils literal"><span class="pre">p</span></code> is true&#8221; to obtain &#8220;the fact that <code class="docutils literal"><span class="pre">q</span></code> is true.&#8221;</p>
<p>Indeed, if <code class="docutils literal"><span class="pre">p</span> <span class="pre">:</span> <span class="pre">Prop</span></code> is any proposition, Lean&#8217;s kernel treats any two elements <code class="docutils literal"><span class="pre">t1</span> <span class="pre">t2</span> <span class="pre">:</span> <span class="pre">p</span></code> as being definitionally equal, much the same way as it treats <code class="docutils literal"><span class="pre">(&#955;</span> <span class="pre">x,</span> <span class="pre">t)s</span></code> and <code class="docutils literal"><span class="pre">t[s/x]</span></code> as definitionally equal. This is known as &#8220;proof irrelevance,&#8221; and is consistent with the interpretation in the last paragraph. It means that even though we can treat proofs <code class="docutils literal"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">p</span></code> as ordinary objects in the language of dependent type theory, they carry no information beyond the fact that <code class="docutils literal"><span class="pre">p</span></code> is true.</p>
<p>The two ways we have suggested thinking about the propositions-as-types paradigm differ in a fundamental way. From the constructive point of view, proofs are abstract mathematical objects that are <em>denoted</em> by suitable expressions in dependent type theory. In contrast, if we think in terms of the coding trick described above, then the expressions themselves do not denote anything interesting. Rather, it is the fact that we can write them down and check that they are well-typed that ensures that the proposition in question is true. In other words, the expressions <em>themselves</em> are the proofs.</p>
<p>In the exposition below, we will slip back and forth between these two ways of talking, at times saying that an expression &#8220;constructs&#8221; or &#8220;produces&#8221; or &#8220;returns&#8221; a proof of a proposition, and at other times simply saying that it &#8220;is&#8221; such a proof. This is similar to the way that computer scientists occasionally blur the distinction between syntax and semantics by saying, at times, that a program &#8220;computes&#8221; a certain function, and at other times speaking as though the program &#8220;is&#8221; the function in question.</p>
<p>In any case, all that really matters is that the bottom line is clear. To formally express a mathematical assertion in the language of dependent type theory, we need to exhibit a term <code class="docutils literal"><span class="pre">p</span> <span class="pre">:</span> <span class="pre">Prop</span></code>. To <em>prove</em> that assertion, we need to exhibit a term <code class="docutils literal"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">p</span></code>. Lean&#8217;s task, as a proof assistant, is to help us to construct such a term, <code class="docutils literal"><span class="pre">t</span></code>, and to verify that it is well-formed and has the correct type.</p>
</div>
<div class="section" id="working-with-propositions-as-types">
<h2>3.2. Working with Propositions as Types<a class="headerlink" href="#working-with-propositions-as-types" title="Permalink to this headline">&#182;</a></h2>
<p>In the propositions-as-types paradigm, theorems involving only <code class="docutils literal"><span class="pre">&#8594;</span></code> can be proved using lambda abstraction and application. In Lean, the <code class="docutils literal"><span class="pre">theorem</span></code> command introduces a new theorem:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=constants%20p%20q%20:%20Prop%0A%0Atheorem%20t1%20:%20p%20%E2%86%92%20q%20%E2%86%92%20p%20:=%20%CE%BB%20hp%20:%20p,%20%CE%BB%20hq%20:%20q,%20hp" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">constants</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kd">theorem</span> <span class="n">t1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">p</span> <span class="o">:=</span> <span class="bp">&#955;</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="bp">&#955;</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span> <span class="n">hp</span>
</pre></div>
</div>
</div><p>This looks exactly like the definition of the constant function in the last chapter, the only difference being that the arguments are elements of <code class="docutils literal"><span class="pre">Prop</span></code> rather than <code class="docutils literal"><span class="pre">Type</span></code>. Intuitively, our proof of <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code> assumes <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code> are true, and uses the first hypothesis (trivially) to establish that the conclusion, <code class="docutils literal"><span class="pre">p</span></code>, is true.</p>
<p>Note that the <code class="docutils literal"><span class="pre">theorem</span></code> command is really a version of the <code class="docutils literal"><span class="pre">definition</span></code> command: under the propositions and types correspondence, proving the theorem <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code> is really the same as defining an element of the associated type. To the kernel type checker, there is no difference between the two.</p>
<p>There are a few pragmatic differences between definitions and theorems, however. In normal circumstances, it is never necessary to unfold the &#8220;definition&#8221; of a theorem; by proof irrelevance, any two proofs of that theorem are definitionally equal. Once the proof of a theorem is complete, typically we only need to know that the proof exists; it doesn&#8217;t matter what the proof is. In light of that fact, Lean tags proofs as <em>irreducible</em>, which serves as a hint to the parser (more precisely, the <em>elaborator</em>) that there is generally no need to unfold it when processing a file. In fact, Lean is generally able to process and check proofs in parallel, since assessing the correctness of one proof does not require knowing the details of another.</p>
<p>As with definitions, the <code class="docutils literal"><span class="pre">#print</span></code> command will show you the proof of a theorem.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=constants%20p%20q%20:%20Prop%0A%0A--%20BEGIN%0Atheorem%20t1%20:%20p%20%E2%86%92%20q%20%E2%86%92%20p%20:=%20%CE%BB%20hp%20:%20p,%20%CE%BB%20hq%20:%20q,%20hp%0A%0A#print%20t1%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">t1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">p</span> <span class="o">:=</span> <span class="bp">&#955;</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="bp">&#955;</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span> <span class="n">hp</span>

<span class="k">#print</span> <span class="n">t1</span>
</pre></div>
</div>
</div><p>Notice that the lambda abstractions <code class="docutils literal"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">hq</span> <span class="pre">:</span> <span class="pre">q</span></code> can be viewed as temporary assumptions in the proof of <code class="docutils literal"><span class="pre">t1</span></code>. Lean provides the alternative syntax <code class="docutils literal"><span class="pre">assume</span></code> for such a lambda abstraction:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=constants%20p%20q%20:%20Prop%0A%0A--%20BEGIN%0Atheorem%20t1%20:%20p%20%E2%86%92%20q%20%E2%86%92%20p%20:=%0Aassume%20hp%20:%20p,%0Aassume%20hq%20:%20q,%0Ahp%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">t1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span>
<span class="n">hp</span>
</pre></div>
</div>
</div><p>Lean also allows us to specify the type of the final term <code class="docutils literal"><span class="pre">hp</span></code>, explicitly, with a <code class="docutils literal"><span class="pre">show</span></code> statement.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=constants%20p%20q%20:%20Prop%0A%0A--%20BEGIN%0Atheorem%20t1%20:%20p%20%E2%86%92%20q%20%E2%86%92%20p%20:=%0Aassume%20hp%20:%20p,%0Aassume%20hq%20:%20q,%0Ashow%20p,%20from%20hp%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">t1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span>
<span class="k">show</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">hp</span>
</pre></div>
</div>
</div><p>Adding such extra information can improve the clarity of a proof and help detect errors when writing a proof. The <code class="docutils literal"><span class="pre">show</span></code> command does nothing more than annotate the type, and, internally, all the presentations of <code class="docutils literal"><span class="pre">t1</span></code> that we have seen produce the same term. Lean also allows you to use the alternative syntax <code class="docutils literal"><span class="pre">lemma</span></code> instead of theorem:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=constants%20p%20q%20:%20Prop%0A%0A--%20BEGIN%0Alemma%20t1%20:%20p%20%E2%86%92%20q%20%E2%86%92%20p%20:=%0Aassume%20hp%20:%20p,%0Aassume%20hq%20:%20q,%0Ashow%20p,%20from%20hp%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">lemma</span> <span class="n">t1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span>
<span class="k">show</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">hp</span>
</pre></div>
</div>
</div><p>As with ordinary definitions, we can move the lambda-abstracted variables to the left of the colon:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=constants%20p%20q%20:%20Prop%0A%0A--%20BEGIN%0Atheorem%20t1%20(hp%20:%20p)%20(hq%20:%20q)%20:%20p%20:=%20hp%0A%0A#check%20t1%20%20%20%20--%20p%20%E2%86%92%20q%20%E2%86%92%20p%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">t1</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">hp</span>

<span class="k">#check</span> <span class="n">t1</span>    <span class="c1">-- p &#8594; q &#8594; p</span>
</pre></div>
</div>
</div><p>Now we can apply the theorem <code class="docutils literal"><span class="pre">t1</span></code> just as a function application.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=constants%20p%20q%20:%20Prop%0A%0Atheorem%20t1%20(hp%20:%20p)%20(hq%20:%20q)%20:%20p%20:=%20hp%0A%0A--%20BEGIN%0Aaxiom%20hp%20:%20p%0A%0Atheorem%20t2%20:%20q%20%E2%86%92%20p%20:=%20t1%20hp%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">axiom</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span>

<span class="kd">theorem</span> <span class="n">t2</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">t1</span> <span class="n">hp</span>
</pre></div>
</div>
</div><p>Here, the <code class="docutils literal"><span class="pre">axiom</span></code> command is alternative syntax for <code class="docutils literal"><span class="pre">constant</span></code>. Declaring a &#8220;constant&#8221; <code class="docutils literal"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> is tantamount to declaring that <code class="docutils literal"><span class="pre">p</span></code> is true, as witnessed by <code class="docutils literal"><span class="pre">hp</span></code>. Applying the theorem <code class="docutils literal"><span class="pre">t1</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code> to the fact <code class="docutils literal"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> that <code class="docutils literal"><span class="pre">p</span></code> is true yields the theorem <code class="docutils literal"><span class="pre">t2</span> <span class="pre">:</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code>.</p>
<p>Notice, by the way, that the original theorem <code class="docutils literal"><span class="pre">t1</span></code> is true for <em>any</em> propositions <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code>, not just the particular constants declared. So it would be more natural to define the theorem so that it quantifies over those, too:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=theorem%20t1%20(p%20q%20:%20Prop)%20(hp%20:%20p)%20(hq%20:%20q)%20:%20p%20:=%20hp%0A%0A#check%20t1" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">t1</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">hp</span>

<span class="k">#check</span> <span class="n">t1</span>
</pre></div>
</div>
</div><p>The type of <code class="docutils literal"><span class="pre">t1</span></code> is now <code class="docutils literal"><span class="pre">&#8704;</span> <span class="pre">p</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Prop,</span> <span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code>. We can read this as the assertion &#8220;for every pair of propositions <code class="docutils literal"><span class="pre">p</span> <span class="pre">q</span></code>, we have <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code>.&#8221; The symbol <code class="docutils literal"><span class="pre">&#8704;</span></code> is alternate syntax for <code class="docutils literal"><span class="pre">&#928;</span></code>, and later we will see how Pi types let us model universal quantifiers more generally. For example, we can move all parameters to the right of the colon:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=theorem%20t1%20:%20%E2%88%80%20(p%20q%20:%20Prop),%20p%20%E2%86%92%20q%20%E2%86%92%20p%20:=%0A%CE%BB%20(p%20q%20:%20Prop)%20(hp%20:%20p)%20(hq%20:%20q),%20hp" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">t1</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="bp">&#955;</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">),</span> <span class="n">hp</span>
</pre></div>
</div>
</div><p>If <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code> have been declared as variables, Lean will generalize them for us automatically:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0A%0Atheorem%20t1%20:%20p%20%E2%86%92%20q%20%E2%86%92%20p%20:=%20%CE%BB%20(hp%20:%20p)%20(hq%20:%20q),%20hp" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kd">theorem</span> <span class="n">t1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">p</span> <span class="o">:=</span> <span class="bp">&#955;</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">),</span> <span class="n">hp</span>
</pre></div>
</div>
</div><p>In fact, by the propositions-as-types correspondence, we can declare the assumption <code class="docutils literal"><span class="pre">hp</span></code> that <code class="docutils literal"><span class="pre">p</span></code> holds, as another variable:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0Avariable%20%20hp%20:%20p%0A%0Atheorem%20t1%20:%20q%20%E2%86%92%20p%20:=%20%CE%BB%20(hq%20:%20q),%20hp" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kd">variable</span>  <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span>

<span class="kd">theorem</span> <span class="n">t1</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">p</span> <span class="o">:=</span> <span class="bp">&#955;</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">),</span> <span class="n">hp</span>
</pre></div>
</div>
</div><p>Lean detects that the proof uses <code class="docutils literal"><span class="pre">hp</span></code> and automatically adds <code class="docutils literal"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> as a premise. In all cases, the command <code class="docutils literal"><span class="pre">#check</span> <span class="pre">t1</span></code> still yields <code class="docutils literal"><span class="pre">&#8704;</span> <span class="pre">p</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Prop,</span> <span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code>. Remember the this type can just as well be written <code class="docutils literal"><span class="pre">&#8704;</span> <span class="pre">(p</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Prop)</span> <span class="pre">(hp</span> <span class="pre">:</span> <span class="pre">p)</span> <span class="pre">(hq</span> <span class="pre">:q),</span> <span class="pre">p</span></code>, since the arrow denotes nothing more than a Pi type in which the target does not depend on the bound variable.</p>
<p>When we generalize <code class="docutils literal"><span class="pre">t1</span></code> in such a way, we can then apply it to different pairs of propositions, to obtain different instances of the general theorem.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=theorem%20t1%20(p%20q%20:%20Prop)%20(hp%20:%20p)%20(hq%20:%20q)%20:%20p%20:=%20hp%0A%0Avariables%20p%20q%20r%20s%20:%20Prop%0A%0A#check%20t1%20p%20q%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20p%20%E2%86%92%20q%20%E2%86%92%20p%0A#check%20t1%20r%20s%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20r%20%E2%86%92%20s%20%E2%86%92%20r%0A#check%20t1%20(r%20%E2%86%92%20s)%20(s%20%E2%86%92%20r)%20%20%20%20--%20(r%20%E2%86%92%20s)%20%E2%86%92%20(s%20%E2%86%92%20r)%20%E2%86%92%20r%20%E2%86%92%20s%0A%0Avariable%20h%20:%20r%20%E2%86%92%20s%0A#check%20t1%20(r%20%E2%86%92%20s)%20(s%20%E2%86%92%20r)%20h%20%20--%20(s%20%E2%86%92%20r)%20%E2%86%92%20r%20%E2%86%92%20s" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">t1</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">hp</span>

<span class="kd">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="k">#check</span> <span class="n">t1</span> <span class="n">p</span> <span class="n">q</span>                <span class="c1">-- p &#8594; q &#8594; p</span>
<span class="k">#check</span> <span class="n">t1</span> <span class="n">r</span> <span class="n">s</span>                <span class="c1">-- r &#8594; s &#8594; r</span>
<span class="k">#check</span> <span class="n">t1</span> <span class="o">(</span><span class="n">r</span> <span class="bp">&#8594;</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span>    <span class="c1">-- (r &#8594; s) &#8594; (s &#8594; r) &#8594; r &#8594; s</span>

<span class="kd">variable</span> <span class="n">h</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">&#8594;</span> <span class="n">s</span>
<span class="k">#check</span> <span class="n">t1</span> <span class="o">(</span><span class="n">r</span> <span class="bp">&#8594;</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="n">h</span>  <span class="c1">-- (s &#8594; r) &#8594; r &#8594; s</span>
</pre></div>
</div>
</div><p>Once again, using the propositions-as-types correspondence, the variable <code class="docutils literal"><span class="pre">h</span></code> of type <code class="docutils literal"><span class="pre">r</span> <span class="pre">&#8594;</span> <span class="pre">s</span></code> can be viewed as the hypothesis, or premise, that <code class="docutils literal"><span class="pre">r</span> <span class="pre">&#8594;</span> <span class="pre">s</span></code> holds.</p>
<p>As another example, let us consider the composition function discussed in the last chapter, now with propositions instead of types.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20r%20s%20:%20Prop%0A%0Atheorem%20t2%20(h%E2%82%81%20:%20q%20%E2%86%92%20r)%20(h%E2%82%82%20:%20p%20%E2%86%92%20q)%20:%20p%20%E2%86%92%20r%20:=%0Aassume%20h%E2%82%83%20:%20p,%0Ashow%20r,%20from%20h%E2%82%81%20(h%E2%82%82%20h%E2%82%83)" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kd">theorem</span> <span class="n">t2</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h&#8323;</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
<span class="k">show</span> <span class="n">r</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8321;</span> <span class="o">(</span><span class="n">h&#8322;</span> <span class="n">h&#8323;</span><span class="o">)</span>
</pre></div>
</div>
</div><p>As a theorem of propositional logic, what does <code class="docutils literal"><span class="pre">t2</span></code> say?</p>
<p>Note that it is often useful to use numeric unicode subscripts, entered as <code class="docutils literal"><span class="pre">\0</span></code>, <code class="docutils literal"><span class="pre">\1</span></code>, <code class="docutils literal"><span class="pre">\2</span></code>, &#8230;, for hypotheses, as we did in this example.</p>
</div>
<div class="section" id="propositional-logic">
<span id="id2"></span><h2>3.3. Propositional Logic<a class="headerlink" href="#propositional-logic" title="Permalink to this headline">&#182;</a></h2>
<p>Lean defines all the standard logical connectives and notation. The propositional connectives come with the following notation:</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="15%" />
<col width="41%" />
<col width="19%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Ascii</td>
<td>Unicode</td>
<td>Emacs shortcut for unicode</td>
<td>Definition</td>
</tr>
<tr class="row-even"><td>true</td>
<td>&#160;</td>
<td>&#160;</td>
<td>true</td>
</tr>
<tr class="row-odd"><td>false</td>
<td>&#160;</td>
<td>&#160;</td>
<td>false</td>
</tr>
<tr class="row-even"><td>not</td>
<td>&#172;</td>
<td><code class="docutils literal"><span class="pre">\not</span></code>, <code class="docutils literal"><span class="pre">\neg</span></code></td>
<td>not</td>
</tr>
<tr class="row-odd"><td>/\</td>
<td>&#8743;</td>
<td><code class="docutils literal"><span class="pre">\and</span></code></td>
<td>and</td>
</tr>
<tr class="row-even"><td>\/</td>
<td>&#8744;</td>
<td><code class="docutils literal"><span class="pre">\or</span></code></td>
<td>or</td>
</tr>
<tr class="row-odd"><td>-&gt;</td>
<td>&#8594;</td>
<td><code class="docutils literal"><span class="pre">\to</span></code>, <code class="docutils literal"><span class="pre">\r</span></code>, <code class="docutils literal"><span class="pre">\imp</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>&lt;-&gt;</td>
<td>&#8596;</td>
<td><code class="docutils literal"><span class="pre">\iff</span></code>, <code class="docutils literal"><span class="pre">\lr</span></code></td>
<td>iff</td>
</tr>
</tbody>
</table>
<p>They all take values in <code class="docutils literal"><span class="pre">Prop</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0A%0A#check%20p%20%E2%86%92%20q%20%E2%86%92%20p%20%E2%88%A7%20q%0A#check%20%C2%ACp%20%E2%86%92%20p%20%E2%86%94%20false%0A#check%20p%20%E2%88%A8%20q%20%E2%86%92%20q%20%E2%88%A8%20p" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="k">#check</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span>
<span class="k">#check</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">p</span> <span class="bp">&#8596;</span> <span class="n">false</span>
<span class="k">#check</span> <span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">q</span> <span class="bp">&#8744;</span> <span class="n">p</span>
</pre></div>
</div>
</div><p>The order of operations is as follows: unary negation <code class="docutils literal"><span class="pre">&#172;</span></code> binds most strongly, then <code class="docutils literal"><span class="pre">&#8743;</span></code>, then <code class="docutils literal"><span class="pre">&#8744;</span></code>, then <code class="docutils literal"><span class="pre">&#8594;</span></code>, and finally <code class="docutils literal"><span class="pre">&#8596;</span></code>. For example, <code class="docutils literal"><span class="pre">a</span> <span class="pre">&#8743;</span> <span class="pre">b</span> <span class="pre">&#8594;</span> <span class="pre">c</span> <span class="pre">&#8744;</span> <span class="pre">d</span> <span class="pre">&#8743;</span> <span class="pre">e</span></code> means <code class="docutils literal"><span class="pre">(a</span> <span class="pre">&#8743;</span> <span class="pre">b)</span> <span class="pre">&#8594;</span> <span class="pre">(c</span> <span class="pre">&#8744;</span> <span class="pre">(d</span> <span class="pre">&#8743;</span> <span class="pre">e))</span></code>. Remember that <code class="docutils literal"><span class="pre">&#8594;</span></code> associates to the right (nothing changes now that the arguments are elements of <code class="docutils literal"><span class="pre">Prop</span></code>, instead of some other <code class="docutils literal"><span class="pre">Type</span></code>), as do the other binary connectives. So if we have <code class="docutils literal"><span class="pre">p</span> <span class="pre">q</span> <span class="pre">r</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, the expression <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">r</span></code> reads &#8220;if <code class="docutils literal"><span class="pre">p</span></code>, then if <code class="docutils literal"><span class="pre">q</span></code>, then <code class="docutils literal"><span class="pre">r</span></code>.&#8221; This is just the &#8220;curried&#8221; form of <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">r</span></code>.</p>
<p>In the last chapter we observed that lambda abstraction can be viewed as an &#8220;introduction rule&#8221; for <code class="docutils literal"><span class="pre">&#8594;</span></code>. In the current setting, it shows how to &#8220;introduce&#8221; or establish an implication. Application can be viewed as an &#8220;elimination rule,&#8221; showing how to &#8220;eliminate&#8221; or use an implication in a proof. The other propositional connectives are defined in Lean&#8217;s library in the file <code class="docutils literal"><span class="pre">init.core</span></code> (see <a class="reference internal" href="interacting_with_lean.html#importing-files"><span class="std std-numref">Section 6.1</span></a> for more information on the library hierarchy), and each connective comes with its canonical introduction and elimination rules.</p>
<div class="section" id="conjunction">
<span id="id3"></span><h3>3.3.1. Conjunction<a class="headerlink" href="#conjunction" title="Permalink to this headline">&#182;</a></h3>
<p>The expression <code class="docutils literal"><span class="pre">and.intro</span> <span class="pre">h1</span> <span class="pre">h2</span></code> builds a proof of <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span></code> using proofs <code class="docutils literal"><span class="pre">h1</span> <span class="pre">:</span> <span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">h2</span> <span class="pre">:</span> <span class="pre">q</span></code>. It is common to describe <code class="docutils literal"><span class="pre">and.intro</span></code> as the <em>and-introduction</em> rule. In the next example we use <code class="docutils literal"><span class="pre">and.intro</span></code> to create a proof of <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0A--%20BEGIN%0A%0Aexample%20(hp%20:%20p)%20(hq%20:%20q)%20:%20p%20%E2%88%A7%20q%20:=%20and.intro%20hp%20hq%0A%0A#check%20assume%20(hp%20:%20p)%20(hq%20:%20q),%20and.intro%20hp%20hq%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">and.intro</span> <span class="n">hp</span> <span class="n">hq</span>

<span class="k">#check</span> <span class="k">assume</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">),</span> <span class="n">and.intro</span> <span class="n">hp</span> <span class="n">hq</span>
</pre></div>
</div>
</div><p>The <code class="docutils literal"><span class="pre">example</span></code> command states a theorem without naming it or storing it in the permanent context. Essentially, it just checks that the given term has the indicated type. It is convenient for illustration, and we will use it often.</p>
<p>The expression <code class="docutils literal"><span class="pre">and.elim_left</span> <span class="pre">h</span></code> creates a proof of <code class="docutils literal"><span class="pre">p</span></code> from a proof <code class="docutils literal"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span></code>. Similarly, <code class="docutils literal"><span class="pre">and.elim_right</span> <span class="pre">h</span></code> is a proof of <code class="docutils literal"><span class="pre">q</span></code>. They are commonly known as the right and left <em>and-elimination</em> rules.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0A--%20BEGIN%0Aexample%20(h%20:%20p%20%E2%88%A7%20q)%20:%20p%20:=%20and.elim_left%20h%0Aexample%20(h%20:%20p%20%E2%88%A7%20q)%20:%20q%20:=%20and.elim_right%20h%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">and.elim_left</span> <span class="n">h</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">and.elim_right</span> <span class="n">h</span>
</pre></div>
</div>
</div><p>Because they are so commonly used, the standard library provides the abbreviations <code class="docutils literal"><span class="pre">and.left</span></code> and <code class="docutils literal"><span class="pre">and.right</span></code> for <code class="docutils literal"><span class="pre">and.elim_left</span></code> and <code class="docutils literal"><span class="pre">and.elim_right</span></code>, respectively.</p>
<p>We can now prove <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8743;</span> <span class="pre">p</span></code> with the following proof term.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0A--%20BEGIN%0Aexample%20(h%20:%20p%20%E2%88%A7%20q)%20:%20q%20%E2%88%A7%20p%20:=%0Aand.intro%20(and.right%20h)%20(and.left%20h)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="n">and.intro</span> <span class="o">(</span><span class="n">and.right</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="n">and.left</span> <span class="n">h</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Notice that and-introduction and and-elimination are similar to the pairing and projection operations for the cartesian product. The difference is that given <code class="docutils literal"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">hq</span> <span class="pre">:</span> <span class="pre">q</span></code>, <code class="docutils literal"><span class="pre">and.intro</span> <span class="pre">hp</span> <span class="pre">hq</span></code> has type <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, while <code class="docutils literal"><span class="pre">pair</span> <span class="pre">hp</span> <span class="pre">hq</span></code> has type <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#215;</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Type</span></code>. The similarity between <code class="docutils literal"><span class="pre">&#8743;</span></code> and <code class="docutils literal"><span class="pre">&#215;</span></code> is another instance of the Curry-Howard isomorphism, but in contrast to implication and the function space constructor, <code class="docutils literal"><span class="pre">&#8743;</span></code> and <code class="docutils literal"><span class="pre">&#215;</span></code> are treated separately in Lean. With the analogy, however, the proof we have just constructed is similar to a function that swaps the elements of a pair.</p>
<p>We will see in <a class="reference internal" href="structures_and_records.html#structures-and-records"><span class="std std-numref">Chapter 9</span></a> that certain types in Lean are <em>structures</em>, which is to say, the type is defined with a single canonical <em>constructor</em> which builds an element of the type from a sequence of suitable arguments. For every <code class="docutils literal"><span class="pre">p</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span></code> is an example: the canonical way to construct an element is to apply <code class="docutils literal"><span class="pre">and.intro</span></code> to suitable arguments <code class="docutils literal"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">hq</span> <span class="pre">:</span> <span class="pre">q</span></code>. Lean allows us to use <em>anonymous constructor</em> notation <code class="docutils literal"><span class="pre">&#10216;arg1,</span> <span class="pre">arg2,</span> <span class="pre">...&#10217;</span></code> in situations like these, when the relevant type is an inductive type and can be inferred from the context. In particular, we can often write <code class="docutils literal"><span class="pre">&#10216;hp,</span> <span class="pre">hq&#10217;</span></code> instead of <code class="docutils literal"><span class="pre">and.intro</span> <span class="pre">hp</span> <span class="pre">hq</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0Avariables%20%20(hp%20:%20p)%20(hq%20:%20q)%0A%0A#check%20(%E2%9F%A8hp,%20hq%E2%9F%A9%20:%20p%20%E2%88%A7%20q)" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kd">variables</span>  <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">(&#10216;</span><span class="n">hp</span><span class="o">,</span> <span class="n">hq</span><span class="o">&#10217;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span>
</pre></div>
</div>
</div><p>These angle brackets are obtained by typing <code class="docutils literal"><span class="pre">\&lt;</span></code> and <code class="docutils literal"><span class="pre">\&gt;</span></code>, respectively. Alternatively, you can use ASCII equivalents <code class="docutils literal"><span class="pre">(|</span></code> and <code class="docutils literal"><span class="pre">|)</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0Avariables%20%20(hp%20:%20p)%20(hq%20:%20q)%0A%0Aexample%20:%20p%20%E2%88%A7%20q%20:=%20(%7Chp,%20hq%7C)" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kd">variables</span>  <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">|</span><span class="n">hp</span><span class="o">,</span> <span class="n">hq</span><span class="bp">|</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Lean provides another useful syntactic gadget. Given an expression <code class="docutils literal"><span class="pre">e</span></code> of an inductive type <code class="docutils literal"><span class="pre">foo</span></code> (possibly applied to some arguments), the notation <code class="docutils literal"><span class="pre">e.bar</span></code> is shorthand for <code class="docutils literal"><span class="pre">foo.bar</span> <span class="pre">e</span></code>. This provides a convenient way of accessing functions without opening a namespace. For example, the following two expressions mean the same thing:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variable%20l%20:%20list%20%E2%84%95%0A%0A#check%20list.head%20l%0A#check%20l.head" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">variable</span> <span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#8469;</span>

<span class="k">#check</span> <span class="n">list.head</span> <span class="n">l</span>
<span class="k">#check</span> <span class="n">l.head</span>
</pre></div>
</div>
</div><p>As a result, given <code class="docutils literal"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span></code>, we can write <code class="docutils literal"><span class="pre">h.left</span></code> for <code class="docutils literal"><span class="pre">and.left</span> <span class="pre">h</span></code> and <code class="docutils literal"><span class="pre">h.right</span></code> for <code class="docutils literal"><span class="pre">and.right</span> <span class="pre">h</span></code>. We can therefore rewrite the sample proof above conveniently as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0A--%20BEGIN%0Aexample%20(h%20:%20p%20%E2%88%A7%20q)%20:%20q%20%E2%88%A7%20p%20:=%0A%E2%9F%A8h.right,%20h.left%E2%9F%A9%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="o">&#10216;</span><span class="n">h.right</span><span class="o">,</span> <span class="n">h.left</span><span class="o">&#10217;</span>
</pre></div>
</div>
</div><p>There is a fine line between brevity and obfuscation, and omitting information in this way can sometimes make a proof harder to read. But for straightforward constructions like the one above, when the type of <code class="docutils literal"><span class="pre">h</span></code> and the goal of the construction are salient, the notation is clean and effective.</p>
<p>It is common to iterate constructions like &#8220;and.&#8221; Lean also allows you to flatten nested constructors that associate to the right, so that these two proofs are equivalent:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0A--%20BEGIN%0Aexample%20(h%20:%20p%20%E2%88%A7%20q)%20:%20q%20%E2%88%A7%20p%20%E2%88%A7%20q:=%0A%E2%9F%A8h.right,%20%E2%9F%A8h.left,%20h.right%E2%9F%A9%E2%9F%A9%0A%0Aexample%20(h%20:%20p%20%E2%88%A7%20q)%20:%20q%20%E2%88%A7%20p%20%E2%88%A7%20q:=%0A%E2%9F%A8h.right,%20h.left,%20h.right%E2%9F%A9%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="n">h.right</span><span class="o">,</span> <span class="o">&#10216;</span><span class="n">h.left</span><span class="o">,</span> <span class="n">h.right</span><span class="o">&#10217;&#10217;</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">:=</span>
<span class="o">&#10216;</span><span class="n">h.right</span><span class="o">,</span> <span class="n">h.left</span><span class="o">,</span> <span class="n">h.right</span><span class="o">&#10217;</span>
</pre></div>
</div>
</div><p>This is often useful as well.</p>
</div>
<div class="section" id="disjunction">
<h3>3.3.2. Disjunction<a class="headerlink" href="#disjunction" title="Permalink to this headline">&#182;</a></h3>
<p>The expression <code class="docutils literal"><span class="pre">or.intro_left</span> <span class="pre">q</span> <span class="pre">hp</span></code> creates a proof of <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span></code> from a proof <code class="docutils literal"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code>. Similarly, <code class="docutils literal"><span class="pre">or.intro_right</span> <span class="pre">p</span> <span class="pre">hq</span></code> creates a proof for <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span></code> using a proof <code class="docutils literal"><span class="pre">hq</span> <span class="pre">:</span> <span class="pre">q</span></code>. These are the left and right <em>or-introduction</em> rules.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0A--%20BEGIN%0Aexample%20(hp%20:%20p)%20:%20p%20%E2%88%A8%20q%20:=%20or.intro_left%20q%20hp%0Aexample%20(hq%20:%20q)%20:%20p%20%E2%88%A8%20q%20:=%20or.intro_right%20p%20hq%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">or.intro_left</span> <span class="n">q</span> <span class="n">hp</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">or.intro_right</span> <span class="n">p</span> <span class="n">hq</span>
</pre></div>
</div>
</div><p>The <em>or-elimination</em> rule is slightly more complicated. The idea is that we can prove <code class="docutils literal"><span class="pre">r</span></code> from <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span></code>, by showing that <code class="docutils literal"><span class="pre">r</span></code> follows from <code class="docutils literal"><span class="pre">p</span></code> and that <code class="docutils literal"><span class="pre">r</span></code> follows from <code class="docutils literal"><span class="pre">q</span></code>. In other words, it is a proof by cases. In the expression <code class="docutils literal"><span class="pre">or.elim</span> <span class="pre">hpq</span> <span class="pre">hpr</span> <span class="pre">hqr</span></code>, <code class="docutils literal"><span class="pre">or.elim</span></code> takes three arguments, <code class="docutils literal"><span class="pre">hpq</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span></code>, <code class="docutils literal"><span class="pre">hpr</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">r</span></code> and <code class="docutils literal"><span class="pre">hqr</span> <span class="pre">:</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">r</span></code>, and produces a proof of <code class="docutils literal"><span class="pre">r</span></code>. In the following example, we use <code class="docutils literal"><span class="pre">or.elim</span></code> to prove <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8744;</span> <span class="pre">p</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20r:%20Prop%0A--%20BEGIN%0Aexample%20(h%20:%20p%20%E2%88%A8%20q)%20:%20q%20%E2%88%A8%20p%20:=%0Aor.elim%20h%0A%20%20(assume%20hp%20:%20p,%0A%20%20%20%20show%20q%20%E2%88%A8%20p,%20from%20or.intro_right%20q%20hp)%0A%20%20(assume%20hq%20:%20q,%0A%20%20%20%20show%20q%20%E2%88%A8%20p,%20from%20or.intro_left%20p%20hq)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8744;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="n">or.elim</span> <span class="n">h</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">q</span> <span class="bp">&#8744;</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">or.intro_right</span> <span class="n">q</span> <span class="n">hp</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">q</span> <span class="bp">&#8744;</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">or.intro_left</span> <span class="n">p</span> <span class="n">hq</span><span class="o">)</span>
</pre></div>
</div>
</div><p>In most cases, the first argument of <code class="docutils literal"><span class="pre">or.intro_right</span></code> and <code class="docutils literal"><span class="pre">or.intro_left</span></code> can be inferred automatically by Lean. Lean therefore provides <code class="docutils literal"><span class="pre">or.inr</span></code> and <code class="docutils literal"><span class="pre">or.inl</span></code> as shorthand for <code class="docutils literal"><span class="pre">or.intro_right</span> <span class="pre">_</span></code> and <code class="docutils literal"><span class="pre">or.intro_left</span> <span class="pre">_</span></code>. Thus the proof term above could be written more concisely:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20r:%20Prop%0A--%20BEGIN%0Aexample%20(h%20:%20p%20%E2%88%A8%20q)%20:%20q%20%E2%88%A8%20p%20:=%0Aor.elim%20h%20(%CE%BB%20hp,%20or.inr%20hp)%20(%CE%BB%20hq,%20or.inl%20hq)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8744;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="n">or.elim</span> <span class="n">h</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">hp</span><span class="o">,</span> <span class="n">or.inr</span> <span class="n">hp</span><span class="o">)</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">hq</span><span class="o">,</span> <span class="n">or.inl</span> <span class="n">hq</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Notice that there is enough information in the full expression for Lean to infer the types of <code class="docutils literal"><span class="pre">hp</span></code> and <code class="docutils literal"><span class="pre">hq</span></code> as well. But using the type annotations in the longer version makes the proof more readable, and can help catch and debug errors.</p>
<p>Because <code class="docutils literal"><span class="pre">or</span></code> has two constructors, we cannot use anonymous constructor notation. But we can still write <code class="docutils literal"><span class="pre">h.elim</span></code> instead of <code class="docutils literal"><span class="pre">or.elim</span> <span class="pre">h</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20r:%20Prop%0A--%20BEGIN%0Aexample%20(h%20:%20p%20%E2%88%A8%20q)%20:%20q%20%E2%88%A8%20p%20:=%0Ah.elim%0A%20%20(assume%20hp%20:%20p,%20or.inr%20hp)%0A%20%20(assume%20hq%20:%20q,%20or.inl%20hq)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8744;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="n">h.elim</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="n">or.inr</span> <span class="n">hp</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span> <span class="n">or.inl</span> <span class="n">hq</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Once again, you should exercise judgment as to whether such abbreviations enhance or diminish readability.</p>
</div>
<div class="section" id="negation-and-falsity">
<h3>3.3.3. Negation and Falsity<a class="headerlink" href="#negation-and-falsity" title="Permalink to this headline">&#182;</a></h3>
<p>Negation, <code class="docutils literal"><span class="pre">&#172;p</span></code>, is actually defined to be <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">false</span></code>, so we obtain <code class="docutils literal"><span class="pre">&#172;p</span></code> by deriving a contradiction from <code class="docutils literal"><span class="pre">p</span></code>. Similarly, the expression <code class="docutils literal"><span class="pre">hnp</span> <span class="pre">hp</span></code> produces a proof of <code class="docutils literal"><span class="pre">false</span></code> from <code class="docutils literal"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">hnp</span> <span class="pre">:</span> <span class="pre">&#172;p</span></code>. The next example uses both these rules to produce a proof of <code class="docutils literal"><span class="pre">(p</span> <span class="pre">&#8594;</span> <span class="pre">q)</span> <span class="pre">&#8594;</span> <span class="pre">&#172;q</span> <span class="pre">&#8594;</span> <span class="pre">&#172;p</span></code>. (The symbol <code class="docutils literal"><span class="pre">&#172;</span></code> is produced by typing <code class="docutils literal"><span class="pre">\not</span></code> or <code class="docutils literal"><span class="pre">\neg</span></code>.)</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0A--%20BEGIN%0Aexample%20(hpq%20:%20p%20%E2%86%92%20q)%20(hnq%20:%20%C2%ACq)%20:%20%C2%ACp%20:=%0Aassume%20hp%20:%20p,%0Ashow%20false,%20from%20hnq%20(hpq%20hp)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">hpq</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">hnq</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
<span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">hnq</span> <span class="o">(</span><span class="n">hpq</span> <span class="n">hp</span><span class="o">)</span>
</pre></div>
</div>
</div><p>The connective <code class="docutils literal"><span class="pre">false</span></code> has a single elimination rule, <code class="docutils literal"><span class="pre">false.elim</span></code>, which expresses the fact that anything follows from a contradiction. This rule is sometimes called <em>ex falso</em> (short for <em>ex falso sequitur quodlibet</em>), or the <em>principle of explosion</em>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0A--%20BEGIN%0Aexample%20(hp%20:%20p)%20(hnp%20:%20%C2%ACp)%20:%20q%20:=%20false.elim%20(hnp%20hp)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hnp</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">false.elim</span> <span class="o">(</span><span class="n">hnp</span> <span class="n">hp</span><span class="o">)</span>
</pre></div>
</div>
</div><p>The arbitrary fact, <code class="docutils literal"><span class="pre">q</span></code>, that follows from falsity is an implicit argument in <code class="docutils literal"><span class="pre">false.elim</span></code> and is inferred automatically. This pattern, deriving an arbitrary fact from contradictory hypotheses, is quite common, and is represented by <code class="docutils literal"><span class="pre">absurd</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0A--%20BEGIN%0Aexample%20(hp%20:%20p)%20(hnp%20:%20%C2%ACp)%20:%20q%20:=%20absurd%20hp%20hnp%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hnp</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">absurd</span> <span class="n">hp</span> <span class="n">hnp</span>
</pre></div>
</div>
</div><p>Here, for example, is a proof of <code class="docutils literal"><span class="pre">&#172;p</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">(q</span> <span class="pre">&#8594;</span> <span class="pre">p)</span> <span class="pre">&#8594;</span> <span class="pre">r</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20r%20:%20Prop%0A--%20BEGIN%0Aexample%20(hnp%20:%20%C2%ACp)%20(hq%20:%20q)%20(hqp%20:%20q%20%E2%86%92%20p)%20:%20r%20:=%0Aabsurd%20(hqp%20hq)%20hnp%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">hnp</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">hqp</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="o">:=</span>
<span class="n">absurd</span> <span class="o">(</span><span class="n">hqp</span> <span class="n">hq</span><span class="o">)</span> <span class="n">hnp</span>
</pre></div>
</div>
</div><p>Incidentally, just as <code class="docutils literal"><span class="pre">false</span></code> has only an elimination rule, <code class="docutils literal"><span class="pre">true</span></code> has only an introduction rule, <code class="docutils literal"><span class="pre">true.intro</span> <span class="pre">:</span> <span class="pre">true</span></code>, sometimes abbreviated <code class="docutils literal"><span class="pre">trivial</span> <span class="pre">:</span> <span class="pre">true</span></code>. In other words, <code class="docutils literal"><span class="pre">true</span></code> is simply true, and has a canonical proof, <code class="docutils literal"><span class="pre">trivial</span></code>.</p>
</div>
<div class="section" id="logical-equivalence">
<h3>3.3.4. Logical Equivalence<a class="headerlink" href="#logical-equivalence" title="Permalink to this headline">&#182;</a></h3>
<p>The expression <code class="docutils literal"><span class="pre">iff.intro</span> <span class="pre">h1</span> <span class="pre">h2</span></code> produces a proof of <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8596;</span> <span class="pre">q</span></code> from <code class="docutils literal"><span class="pre">h1</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code> and <code class="docutils literal"><span class="pre">h2</span> <span class="pre">:</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code>. The expression <code class="docutils literal"><span class="pre">iff.elim_left</span> <span class="pre">h</span></code> produces a proof of <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code> from <code class="docutils literal"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8596;</span> <span class="pre">q</span></code>. Similarly, <code class="docutils literal"><span class="pre">iff.elim_right</span> <span class="pre">h</span></code> produces a proof of <code class="docutils literal"><span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code> from <code class="docutils literal"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8596;</span> <span class="pre">q</span></code>. Here is a proof of <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span> <span class="pre">&#8596;</span> <span class="pre">q</span> <span class="pre">&#8743;</span> <span class="pre">p</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0A--%20BEGIN%0Atheorem%20and_swap%20:%20p%20%E2%88%A7%20q%20%E2%86%94%20q%20%E2%88%A7%20p%20:=%0Aiff.intro%0A%20%20(assume%20h%20:%20p%20%E2%88%A7%20q,%0A%20%20%20%20show%20q%20%E2%88%A7%20p,%20from%20and.intro%20(and.right%20h)%20(and.left%20h))%0A%20%20(assume%20h%20:%20q%20%E2%88%A7%20p,%0A%20%20%20%20show%20p%20%E2%88%A7%20q,%20from%20and.intro%20(and.right%20h)%20(and.left%20h))%0A%0A#check%20and_swap%20p%20q%20%20%20%20--%20p%20%E2%88%A7%20q%20%E2%86%94%20q%20%E2%88%A7%20p%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">and_swap</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span> <span class="bp">&#8596;</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="n">iff.intro</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">and.intro</span> <span class="o">(</span><span class="n">and.right</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="n">and.left</span> <span class="n">h</span><span class="o">))</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">and.intro</span> <span class="o">(</span><span class="n">and.right</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="n">and.left</span> <span class="n">h</span><span class="o">))</span>

<span class="k">#check</span> <span class="n">and_swap</span> <span class="n">p</span> <span class="n">q</span>    <span class="c1">-- p &#8743; q &#8596; q &#8743; p</span>
</pre></div>
</div>
</div><p>Because they represent a form of <em>modus ponens</em>, <code class="docutils literal"><span class="pre">iff.elim_left</span></code> and <code class="docutils literal"><span class="pre">iff.elim_right</span></code> can be abbreviated <code class="docutils literal"><span class="pre">iff.mp</span></code> and <code class="docutils literal"><span class="pre">iff.mpr</span></code>, respectively. In the next example, we use that theorem to derive <code class="docutils literal"><span class="pre">q</span> <span class="pre">&#8743;</span> <span class="pre">p</span></code> from <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0A%0Atheorem%20and_swap%20:%20p%20%E2%88%A7%20q%20%E2%86%94%20q%20%E2%88%A7%20p%20:=%0Aiff.intro%0A%20%20(assume%20h%20:%20p%20%E2%88%A7%20q,%0A%20%20%20%20show%20q%20%E2%88%A7%20p,%20from%20and.intro%20(and.right%20h)%20(and.left%20h))%0A%20%20(assume%20h%20:%20q%20%E2%88%A7%20p,%0A%20%20%20%20show%20p%20%E2%88%A7%20q,%20from%20and.intro%20(and.right%20h)%20(and.left%20h))%0A%0A--%20BEGIN%0Avariable%20h%20:%20p%20%E2%88%A7%20q%0Aexample%20:%20q%20%E2%88%A7%20p%20:=%20iff.mp%20(and_swap%20p%20q)%20h%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">variable</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">iff.mp</span> <span class="o">(</span><span class="n">and_swap</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="n">h</span>
</pre></div>
</div>
</div><p>We can use the anonymous constructor notation to construct a proof of <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8596;</span> <span class="pre">q</span></code> from proofs of the forward and backward directions, and we can also use <code class="docutils literal"><span class="pre">.</span></code> notation with <code class="docutils literal"><span class="pre">mp</span></code> and <code class="docutils literal"><span class="pre">mpr</span></code>. The previous examples can therefore be written concisely as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0A%0A--%20BEGIN%0Atheorem%20and_swap%20:%20p%20%E2%88%A7%20q%20%E2%86%94%20q%20%E2%88%A7%20p%20:=%0A%E2%9F%A8%20%CE%BB%20h,%20%E2%9F%A8h.right,%20h.left%E2%9F%A9,%20%CE%BB%20h,%20%E2%9F%A8h.right,%20h.left%E2%9F%A9%20%E2%9F%A9%0A%0Aexample%20(h%20:%20p%20%E2%88%A7%20q)%20:%20q%20%E2%88%A7%20p%20:=%20(and_swap%20p%20q).mp%20h%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">and_swap</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span> <span class="bp">&#8596;</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="o">&#10216;</span> <span class="bp">&#955;</span> <span class="n">h</span><span class="o">,</span> <span class="o">&#10216;</span><span class="n">h.right</span><span class="o">,</span> <span class="n">h.left</span><span class="o">&#10217;,</span> <span class="bp">&#955;</span> <span class="n">h</span><span class="o">,</span> <span class="o">&#10216;</span><span class="n">h.right</span><span class="o">,</span> <span class="n">h.left</span><span class="o">&#10217;</span> <span class="o">&#10217;</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span> <span class="o">(</span><span class="n">and_swap</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">h</span>
</pre></div>
</div>
</div></div>
</div>
<div class="section" id="introducing-auxiliary-subgoals">
<h2>3.4. Introducing Auxiliary Subgoals<a class="headerlink" href="#introducing-auxiliary-subgoals" title="Permalink to this headline">&#182;</a></h2>
<p>This is a good place to introduce another device Lean offers to help structure long proofs, namely, the <code class="docutils literal"><span class="pre">have</span></code> construct, which introduces an auxiliary subgoal in a proof. Here is a small example, adapted from the last section:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0A%0Aexample%20(h%20:%20p%20%E2%88%A7%20q)%20:%20q%20%E2%88%A7%20p%20:=%0Ahave%20hp%20:%20p,%20from%20and.left%20h,%0Ahave%20hq%20:%20q,%20from%20and.right%20h,%0Ashow%20q%20%E2%88%A7%20p,%20from%20and.intro%20hq%20hp" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">and.left</span> <span class="n">h</span><span class="o">,</span>
<span class="k">have</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">and.right</span> <span class="n">h</span><span class="o">,</span>
<span class="k">show</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">and.intro</span> <span class="n">hq</span> <span class="n">hp</span>
</pre></div>
</div>
</div><p>Internally, the expression <code class="docutils literal"><span class="pre">have</span> <span class="pre">h</span> <span class="pre">:</span> <span class="pre">p,</span> <span class="pre">from</span> <span class="pre">s,</span> <span class="pre">t</span></code> produces the term <code class="docutils literal"><span class="pre">(&#955;</span> <span class="pre">(h</span> <span class="pre">:</span> <span class="pre">p),</span> <span class="pre">t)</span> <span class="pre">s</span></code>. In other words, <code class="docutils literal"><span class="pre">s</span></code> is a proof of <code class="docutils literal"><span class="pre">p</span></code>, <code class="docutils literal"><span class="pre">t</span></code> is a proof of the desired conclusion assuming <code class="docutils literal"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span></code>, and the two are combined by a lambda abstraction and application. This simple device is extremely useful when it comes to structuring long proofs, since we can use intermediate <code class="docutils literal"><span class="pre">have</span></code>&#8217;s as stepping stones leading to the final goal.</p>
<p>Lean also supports a structured way of reasoning backwards from a goal, which models the &#8220;suffices to show&#8221; construction in ordinary mathematics. The next example simply permutes the last two lines in the previous proof.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=variables%20p%20q%20:%20Prop%0A%0Aexample%20(h%20:%20p%20%E2%88%A7%20q)%20:%20q%20%E2%88%A7%20p%20:=%0Ahave%20hp%20:%20p,%20from%20and.left%20h,%0Asuffices%20hq%20:%20q,%20from%20and.intro%20hq%20hp,%0Ashow%20q,%20from%20and.right%20h" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">and.left</span> <span class="n">h</span><span class="o">,</span>
<span class="k">suffices</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">and.intro</span> <span class="n">hq</span> <span class="n">hp</span><span class="o">,</span>
<span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">and.right</span> <span class="n">h</span>
</pre></div>
</div>
</div><p>Writing <code class="docutils literal"><span class="pre">suffices</span> <span class="pre">hq</span> <span class="pre">:</span> <span class="pre">q</span></code> leaves us with two goals. First, we have to show that it indeed suffices to show <code class="docutils literal"><span class="pre">q</span></code>, by proving the original goal of <code class="docutils literal"><span class="pre">q</span> <span class="pre">&#8743;</span> <span class="pre">p</span></code> with the additional hypothesis <code class="docutils literal"><span class="pre">hq</span> <span class="pre">:</span> <span class="pre">q</span></code>. Finally, we have to show <code class="docutils literal"><span class="pre">q</span></code>.</p>
</div>
<div class="section" id="classical-logic">
<span id="id4"></span><h2>3.5. Classical Logic<a class="headerlink" href="#classical-logic" title="Permalink to this headline">&#182;</a></h2>
<p>The introduction and elimination rules we have seen so far are all constructive, which is to say, they reflect a computational understanding of the logical connectives based on the propositions-as-types correspondence. Ordinary classical logic adds to this the law of the excluded middle, <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">&#172;p</span></code>. To use this principle, you have to open the classical namespace.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20classical%0A%0Avariable%20p%20:%20Prop%0A#check%20em%20p" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variable</span> <span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="k">#check</span> <span class="n">em</span> <span class="n">p</span>
</pre></div>
</div>
</div><p>Intuitively, the constructive &#8220;or&#8221; is very strong: asserting <code class="docutils literal"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span></code> amounts to knowing which is the case. If <code class="docutils literal"><span class="pre">RH</span></code> represents the Riemann hypothesis, a classical mathematician is willing to assert <code class="docutils literal"><span class="pre">RH</span> <span class="pre">&#8744;</span> <span class="pre">&#172;RH</span></code>, even though we cannot yet assert either disjunct.</p>
<p>One consequence of the law of the excluded middle is the principle of double-negation elimination:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20classical%0A%0A--%20BEGIN%0Atheorem%20dne%20%7Bp%20:%20Prop%7D%20(h%20:%20%C2%AC%C2%ACp)%20:%20p%20:=%0Aor.elim%20(em%20p)%0A%20%20(assume%20hp%20:%20p,%20hp)%0A%20%20(assume%20hnp%20:%20%C2%ACp,%20absurd%20hnp%20h)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">dne</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;&#172;</span><span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">:=</span>
<span class="n">or.elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">hnp</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">hnp</span> <span class="n">h</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Double-negation elimination allows one to prove any proposition, <code class="docutils literal"><span class="pre">p</span></code>, by assuming <code class="docutils literal"><span class="pre">&#172;p</span></code> and deriving <code class="docutils literal"><span class="pre">false</span></code>, because that amounts to proving <code class="docutils literal"><span class="pre">&#172;&#172;p</span></code>. In other words, double-negation elimination allows one to carry out a proof by contradiction, something which is not generally possible in constructive logic. As an exercise, you might try proving the converse, that is, showing that <code class="docutils literal"><span class="pre">em</span></code> can be proved from <code class="docutils literal"><span class="pre">dne</span></code>.</p>
<p>The classical axioms also give you access to additional patterns of proof that can be justified by appeal to <code class="docutils literal"><span class="pre">em</span></code>. For example, one can carry out a proof by cases:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20classical%0A%0Avariable%20p%20:%20Prop%0A%0A--%20BEGIN%0Aexample%20(h%20:%20%C2%AC%C2%ACp)%20:%20p%20:=%0Aby_cases%0A%20%20(assume%20h1%20:%20p,%20h1)%0A%20%20(assume%20h1%20:%20%C2%ACp,%20absurd%20h1%20h)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;&#172;</span><span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">:=</span>
<span class="n">by_cases</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="n">h1</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">h1</span> <span class="n">h</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Or you can carry out a proof by contradiction:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20classical%0A%0Avariable%20p%20:%20Prop%0A%0A--%20BEGIN%0Aexample%20(h%20:%20%C2%AC%C2%ACp)%20:%20p%20:=%0Aby_contradiction%0A%20%20(assume%20h1%20:%20%C2%ACp,%0A%20%20%20%20show%20false,%20from%20h%20h1)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;&#172;</span><span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">:=</span>
<span class="n">by_contradiction</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">h</span> <span class="n">h1</span><span class="o">)</span>
</pre></div>
</div>
</div><p>If you are not used to thinking constructively, it may take some time for you to get a sense of where classical reasoning is used. It is needed in the following example because, from a constructive standpoint, knowing that <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code> are not both true does not necessarily tell you which one is false:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20classical%0A%0Avariables%20p%20q%20:%20Prop%0A%0A--%20BEGIN%0Aexample%20(h%20:%20%C2%AC(p%20%E2%88%A7%20q))%20:%20%C2%ACp%20%E2%88%A8%20%C2%ACq%20:=%0Aor.elim%20(em%20p)%0A%20%20(assume%20hp%20:%20p,%0A%20%20%20%20or.inr%0A%20%20%20%20%20%20(show%20%C2%ACq,%20from%0A%20%20%20%20%20%20%20%20assume%20hq%20:%20q,%0A%20%20%20%20%20%20%20%20h%20%E2%9F%A8hp,%20hq%E2%9F%A9))%0A%20%20(assume%20hp%20:%20%C2%ACp,%0A%20%20%20%20or.inl%20hp)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">))</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span><span class="n">q</span> <span class="o">:=</span>
<span class="n">or.elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">or.inr</span>
      <span class="o">(</span><span class="k">show</span> <span class="bp">&#172;</span><span class="n">q</span><span class="o">,</span> <span class="k">from</span>
        <span class="k">assume</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span>
        <span class="n">h</span> <span class="o">&#10216;</span><span class="n">hp</span><span class="o">,</span> <span class="n">hq</span><span class="o">&#10217;))</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">hp</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span><span class="o">,</span>
    <span class="n">or.inl</span> <span class="n">hp</span><span class="o">)</span>
</pre></div>
</div>
</div><p>We will see later that there <em>are</em> situations in constructive logic where principles like excluded middle and double-negation elimination are permissible, and Lean supports the use of classical reasoning in such contexts without relying on excluded middle.</p>
<p>The full list of axioms that are used in Lean to support classical reasoning are discussed in <a class="reference internal" href="axioms_and_computation.html#axioms-and-computation"><span class="std std-numref">Chapter 11</span></a>.</p>
</div>
<div class="section" id="examples-of-propositional-validities">
<span id="id5"></span><h2>3.6. Examples of Propositional Validities<a class="headerlink" href="#examples-of-propositional-validities" title="Permalink to this headline">&#182;</a></h2>
<p>Lean&#8217;s standard library contains proofs of many valid statements of propositional logic, all of which you are free to use in proofs of your own. The following list includes a number of common identities. The ones that require classical reasoning are grouped together at the end, while the rest are constructively valid.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20classical%0A%0Avariables%20p%20q%20r%20s%20:%20Prop%0A%0A--%20commutativity%20of%20%E2%88%A7%20and%20%E2%88%A8%0Aexample%20:%20p%20%E2%88%A7%20q%20%E2%86%94%20q%20%E2%88%A7%20p%20:=%20sorry%0Aexample%20:%20p%20%E2%88%A8%20q%20%E2%86%94%20q%20%E2%88%A8%20p%20:=%20sorry%0A%0A--%20associativity%20of%20%E2%88%A7%20and%20%E2%88%A8%0Aexample%20:%20(p%20%E2%88%A7%20q)%20%E2%88%A7%20r%20%E2%86%94%20p%20%E2%88%A7%20(q%20%E2%88%A7%20r)%20:=%20sorry%0Aexample%20:%20(p%20%E2%88%A8%20q)%20%E2%88%A8%20r%20%E2%86%94%20p%20%E2%88%A8%20(q%20%E2%88%A8%20r)%20:=%20sorry%0A%0A--%20distributivity%0Aexample%20:%20p%20%E2%88%A7%20(q%20%E2%88%A8%20r)%20%E2%86%94%20(p%20%E2%88%A7%20q)%20%E2%88%A8%20(p%20%E2%88%A7%20r)%20:=%20sorry%0Aexample%20:%20p%20%E2%88%A8%20(q%20%E2%88%A7%20r)%20%E2%86%94%20(p%20%E2%88%A8%20q)%20%E2%88%A7%20(p%20%E2%88%A8%20r)%20:=%20sorry%0A%0A--%20other%20properties%0Aexample%20:%20(p%20%E2%86%92%20(q%20%E2%86%92%20r))%20%E2%86%94%20(p%20%E2%88%A7%20q%20%E2%86%92%20r)%20:=%20sorry%0Aexample%20:%20((p%20%E2%88%A8%20q)%20%E2%86%92%20r)%20%E2%86%94%20(p%20%E2%86%92%20r)%20%E2%88%A7%20(q%20%E2%86%92%20r)%20:=%20sorry%0Aexample%20:%20%C2%AC(p%20%E2%88%A8%20q)%20%E2%86%94%20%C2%ACp%20%E2%88%A7%20%C2%ACq%20:=%20sorry%0Aexample%20:%20%C2%ACp%20%E2%88%A8%20%C2%ACq%20%E2%86%92%20%C2%AC(p%20%E2%88%A7%20q)%20:=%20sorry%0Aexample%20:%20%C2%AC(p%20%E2%88%A7%20%C2%ACp)%20:=%20sorry%0Aexample%20:%20p%20%E2%88%A7%20%C2%ACq%20%E2%86%92%20%C2%AC(p%20%E2%86%92%20q)%20:=%20sorry%0Aexample%20:%20%C2%ACp%20%E2%86%92%20(p%20%E2%86%92%20q)%20:=%20sorry%0Aexample%20:%20(%C2%ACp%20%E2%88%A8%20q)%20%E2%86%92%20(p%20%E2%86%92%20q)%20:=%20sorry%0Aexample%20:%20p%20%E2%88%A8%20false%20%E2%86%94%20p%20:=%20sorry%0Aexample%20:%20p%20%E2%88%A7%20false%20%E2%86%94%20false%20:=%20sorry%0Aexample%20:%20%C2%AC(p%20%E2%86%94%20%C2%ACp)%20:=%20sorry%0Aexample%20:%20(p%20%E2%86%92%20q)%20%E2%86%92%20(%C2%ACq%20%E2%86%92%20%C2%ACp)%20:=%20sorry%0A%0A--%20these%20require%20classical%20reasoning%0Aexample%20:%20(p%20%E2%86%92%20r%20%E2%88%A8%20s)%20%E2%86%92%20((p%20%E2%86%92%20r)%20%E2%88%A8%20(p%20%E2%86%92%20s))%20:=%20sorry%0Aexample%20:%20%C2%AC(p%20%E2%88%A7%20q)%20%E2%86%92%20%C2%ACp%20%E2%88%A8%20%C2%ACq%20:=%20sorry%0Aexample%20:%20%C2%AC(p%20%E2%86%92%20q)%20%E2%86%92%20p%20%E2%88%A7%20%C2%ACq%20:=%20sorry%0Aexample%20:%20(p%20%E2%86%92%20q)%20%E2%86%92%20(%C2%ACp%20%E2%88%A8%20q)%20:=%20sorry%0Aexample%20:%20(%C2%ACq%20%E2%86%92%20%C2%ACp)%20%E2%86%92%20(p%20%E2%86%92%20q)%20:=%20sorry%0Aexample%20:%20p%20%E2%88%A8%20%C2%ACp%20:=%20sorry%0Aexample%20:%20(((p%20%E2%86%92%20q)%20%E2%86%92%20p)%20%E2%86%92%20p)%20:=%20sorry" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="c1">-- commutativity of &#8743; and &#8744;</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span> <span class="bp">&#8596;</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span> <span class="bp">&#8596;</span> <span class="n">q</span> <span class="bp">&#8744;</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c1">-- associativity of &#8743; and &#8744;</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">r</span> <span class="bp">&#8596;</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8744;</span> <span class="n">r</span> <span class="bp">&#8596;</span> <span class="n">p</span> <span class="bp">&#8744;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8744;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c1">-- distributivity</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8744;</span> <span class="n">r</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8744;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8744;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c1">-- other properties</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">))</span> <span class="bp">&#8596;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">((</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span><span class="n">q</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span><span class="n">q</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span><span class="n">q</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">false</span> <span class="bp">&#8596;</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">false</span> <span class="bp">&#8596;</span> <span class="n">false</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8596;</span> <span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="bp">&#172;</span><span class="n">q</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c1">-- these require classical reasoning</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">r</span> <span class="bp">&#8744;</span> <span class="n">s</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">((</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="bp">&#8744;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">s</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span><span class="n">q</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span><span class="n">q</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#172;</span><span class="n">q</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(((</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">p</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>
</div>
</div><p>The <code class="docutils literal"><span class="pre">sorry</span></code> identifier magically produces a proof of anything, or provides an object of any data type at all. Of course, it is unsound as a proof method &#8211; for example, you can use it to prove <code class="docutils literal"><span class="pre">false</span></code> &#8211; and Lean produces severe warnings when files use or import theorems which depend on it. But it is very useful for building long proofs incrementally. Start writing the proof from the top down, using <code class="docutils literal"><span class="pre">sorry</span></code> to fill in subproofs. Make sure Lean accepts the term with all the <code class="docutils literal"><span class="pre">sorry</span></code>&#8217;s; if not, there are errors that you need to correct. Then go back and replace each <code class="docutils literal"><span class="pre">sorry</span></code> with an actual proof, until no more remain.</p>
<p>Here is another useful trick. Instead of using <code class="docutils literal"><span class="pre">sorry</span></code>, you can use an underscore <code class="docutils literal"><span class="pre">_</span></code> as a placeholder. Recall that this tells Lean that the argument is implicit, and should be filled in automatically. If Lean tries to do so and fails, it returns with an error message &#8220;don&#8217;t know how to synthesize placeholder.&#8221; This is followed by the type of the term it is expecting, and all the objects and hypothesis available in the context. In other words, for each unresolved placeholder, Lean reports the subgoal that needs to be filled at that point. You can then construct a proof by incrementally filling in these placeholders.</p>
<p>For reference, here are two sample proofs of validities taken from the list above.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20classical%0A%0Avariables%20p%20q%20r%20:%20Prop%0A%0A--%20distributivity%0Aexample%20:%20p%20%E2%88%A7%20(q%20%E2%88%A8%20r)%20%E2%86%94%20(p%20%E2%88%A7%20q)%20%E2%88%A8%20(p%20%E2%88%A7%20r)%20:=%0Aiff.intro%0A%20%20(assume%20h%20:%20p%20%E2%88%A7%20(q%20%E2%88%A8%20r),%0A%20%20%20%20have%20hp%20:%20p,%20from%20h.left,%0A%20%20%20%20or.elim%20(h.right)%0A%20%20%20%20%20%20(assume%20hq%20:%20q,%0A%20%20%20%20%20%20%20%20show%20(p%20%E2%88%A7%20q)%20%E2%88%A8%20(p%20%E2%88%A7%20r),%20from%20or.inl%20%E2%9F%A8hp,%20hq%E2%9F%A9)%0A%20%20%20%20%20%20(assume%20hr%20:%20r,%0A%20%20%20%20%20%20%20%20show%20(p%20%E2%88%A7%20q)%20%E2%88%A8%20(p%20%E2%88%A7%20r),%20from%20or.inr%20%E2%9F%A8hp,%20hr%E2%9F%A9))%0A%20%20(assume%20h%20:%20(p%20%E2%88%A7%20q)%20%E2%88%A8%20(p%20%E2%88%A7%20r),%0A%20%20%20%20or.elim%20h%0A%20%20%20%20%20%20(assume%20hpq%20:%20p%20%E2%88%A7%20q,%0A%20%20%20%20%20%20%20%20have%20hp%20:%20p,%20from%20hpq.left,%0A%20%20%20%20%20%20%20%20have%20hq%20:%20q,%20from%20hpq.right,%0A%20%20%20%20%20%20%20%20show%20p%20%E2%88%A7%20(q%20%E2%88%A8%20r),%20from%20%E2%9F%A8hp,%20or.inl%20hq%E2%9F%A9)%0A%20%20%20%20%20%20(assume%20hpr%20:%20p%20%E2%88%A7%20r,%0A%20%20%20%20%20%20%20%20have%20hp%20:%20p,%20from%20hpr.left,%0A%20%20%20%20%20%20%20%20have%20hr%20:%20r,%20from%20hpr.right,%0A%20%20%20%20%20%20%20%20show%20p%20%E2%88%A7%20(q%20%E2%88%A8%20r),%20from%20%E2%9F%A8hp,%20or.inr%20hr%E2%9F%A9))%0A%0A--%20an%20example%20that%20requires%20classical%20reasoning%0Aexample%20:%20%C2%AC(p%20%E2%88%A7%20%C2%ACq)%20%E2%86%92%20(p%20%E2%86%92%20q)%20:=%0Aassume%20h%20:%20%C2%AC(p%20%E2%88%A7%20%C2%ACq),%0Aassume%20hp%20:%20p,%0Ashow%20q,%20from%0A%20%20or.elim%20(em%20q)%0A%20%20%20%20(assume%20hq%20:%20q,%20hq)%0A%20%20%20%20(assume%20hnq%20:%20%C2%ACq,%20absurd%20(and.intro%20hp%20hnq)%20h)" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">open</span> <span class="n">classical</span>

<span class="kd">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="c1">-- distributivity</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8744;</span> <span class="n">r</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8744;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">iff.intro</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8744;</span> <span class="n">r</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.left</span><span class="o">,</span>
    <span class="n">or.elim</span> <span class="o">(</span><span class="n">h.right</span><span class="o">)</span>
      <span class="o">(</span><span class="k">assume</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span>
        <span class="k">show</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8744;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">),</span> <span class="k">from</span> <span class="n">or.inl</span> <span class="o">&#10216;</span><span class="n">hp</span><span class="o">,</span> <span class="n">hq</span><span class="o">&#10217;)</span>
      <span class="o">(</span><span class="k">assume</span> <span class="n">hr</span> <span class="o">:</span> <span class="n">r</span><span class="o">,</span>
        <span class="k">show</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8744;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">),</span> <span class="k">from</span> <span class="n">or.inr</span> <span class="o">&#10216;</span><span class="n">hp</span><span class="o">,</span> <span class="n">hr</span><span class="o">&#10217;))</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8744;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">),</span>
    <span class="n">or.elim</span> <span class="n">h</span>
      <span class="o">(</span><span class="k">assume</span> <span class="n">hpq</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">hpq.left</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">hpq.right</span><span class="o">,</span>
        <span class="k">show</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8744;</span> <span class="n">r</span><span class="o">),</span> <span class="k">from</span> <span class="o">&#10216;</span><span class="n">hp</span><span class="o">,</span> <span class="n">or.inl</span> <span class="n">hq</span><span class="o">&#10217;)</span>
      <span class="o">(</span><span class="k">assume</span> <span class="n">hpr</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">hpr.left</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hr</span> <span class="o">:</span> <span class="n">r</span><span class="o">,</span> <span class="k">from</span> <span class="n">hpr.right</span><span class="o">,</span>
        <span class="k">show</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8744;</span> <span class="n">r</span><span class="o">),</span> <span class="k">from</span> <span class="o">&#10216;</span><span class="n">hp</span><span class="o">,</span> <span class="n">or.inr</span> <span class="n">hr</span><span class="o">&#10217;))</span>

<span class="c1">-- an example that requires classical reasoning</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span><span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span><span class="n">q</span><span class="o">),</span>
<span class="k">assume</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
<span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span>
  <span class="n">or.elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">q</span><span class="o">)</span>
    <span class="o">(</span><span class="k">assume</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span> <span class="n">hq</span><span class="o">)</span>
    <span class="o">(</span><span class="k">assume</span> <span class="n">hnq</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">q</span><span class="o">,</span> <span class="n">absurd</span> <span class="o">(</span><span class="n">and.intro</span> <span class="n">hp</span> <span class="n">hnq</span><span class="o">)</span> <span class="n">h</span><span class="o">)</span>
</pre></div>
</div>
</div></div>
<div class="section" id="exercises">
<h2>3.7. Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">&#182;</a></h2>
<ol class="arabic simple">
<li>Prove as many identities from the previous section as you can, replacing the &#8220;sorry&#8221; placeholders with actual proofs.</li>
<li>Prove <code class="docutils literal"><span class="pre">&#172;(p</span> <span class="pre">&#8596;</span> <span class="pre">&#172;p)</span></code> without using classical logic.</li>
</ol>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Theorem Proving in Lean</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dependent_type_theory.html">2. Dependent Type Theory</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">3. Propositions and Proofs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#propositions-as-types">3.1. Propositions as Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#working-with-propositions-as-types">3.2. Working with Propositions as Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#propositional-logic">3.3. Propositional Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#introducing-auxiliary-subgoals">3.4. Introducing Auxiliary Subgoals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#classical-logic">3.5. Classical Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples-of-propositional-validities">3.6. Examples of Propositional Validities</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">3.7. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="quantifiers_and_equality.html">4. Quantifiers and Equality</a></li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">5. Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="interacting_with_lean.html">6. Interacting with Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="inductive_types.html">7. Inductive Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="induction_and_recursion.html">8. Induction and Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="structures_and_records.html">9. Structures and Records</a></li>
<li class="toctree-l1"><a class="reference internal" href="type_classes.html">10. Type Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="axioms_and_computation.html">11. Axioms and Computation</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="theorem_proving_in_lean.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jeremy Avigad, Leonardo de Moura, and Soonho Kong.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/propositions_and_proofs.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>